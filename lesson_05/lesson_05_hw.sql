/* Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение” №1
Описание задания: Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
*/

drop database if exists lesson_05;
create database lesson_05;
use lesson_05;

-- создание таблиц
create table users (
	id serial,
    name varchar(50),
    birthday_at varchar(50),
    month_of_birth varchar(50),
    created_at datetime,
    updated_at datetime
);

-- наполнение нужными данными
insert into users (name, birthday_at, month_of_birth)
values
	('john', '20.05.2017 8:10', 'may'),
    ('jack', '20.08.1995 8:10', 'august'),
    ('jim', '20.10.1983 8:10', 'october');

-- скрипт самого задания
update users set created_at = now(), updated_at = now();

/* Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение” №2
Описание задания: Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате "20.10.2017 8:10". Необходимо преобразовать поля к типу DATETIME, сохранив введеные ранее значения.
*/

-- создание таблиц
-- используется таблица из прошлого задания

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
alter table users add birthday_at_2 datetime after birthday_at;
-- шаблон в str_to_date может быть немного другим в зависимости от точного формата даты, который используется (01.10 или 1.10). Из примера в описании задания непонятно.
update users set birthday_at_2 = str_to_date(birthday_at, '%e.%c.%Y %k:%i');
alter table users drop column birthday_at;
alter table users change birthday_at_2 birthday_at datetime;

/* Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение” №3
Описание задания: В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value. Однако, нулевые запасы должны выводиться в конце, после всех записей.
*/

-- создание таблиц
create table storehouses_products (
	id serial,
    value bigint,
    value_for_multiplication bigint
);

-- наполнение нужными данными
insert into storehouses_products (value, value_for_multiplication)
values
	(1, 1),
    (30, 2),
    (500, 3),
    (2500, 4),
    (0, 5),
    (0, null);

-- скрипт самого задания
-- нашел решение в интернете, но не могу понять, как именно оно работает. Буду благодарен за пояснение
select (value) from storehouses_products order by value = 0, value;

/* Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение” №4
Описание задания: (по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. Месяцы заданы в виде списка английских названий ('may', 'august')
*/

-- создание таблиц
-- используется таблица из прошлого задания

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
select * from users where month_of_birth rlike '^(may|august)$';

/* Практическое задание по теме “Операторы, фильтрация, сортировка и ограничение” №5
Описание задания: (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.
*/

-- создание таблиц
-- используется таблица из прошлого задания (storehouses_products)

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
-- сделал по аналогии с заданием №3, но синтаксис по-прежнему непонятен
select * from storehouses_products where id in (5, 1, 2) order by id=2, id=1, id=5;

/* Практическое задание по теме “Агрегация данных” №1
Описание задания: Подсчитайте средний возраст пользователей в таблице users
*/

-- создание таблиц
-- используется таблица из прошлого задания

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
select round(avg(year(birthday_at))) as average_year from users;

/* Практическое задание по теме “Агрегация данных” №2
Описание задания: Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. Следует учесть, что необходимы дни недели текущего года, а не года рождения.
*/

-- создание таблиц
-- используется таблица из прошлого задания

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
select dayname(date_format(birthday_at, '2019-%m-%d')) as day_name, count(birthday_at) as count from users
group by dayname(date_format(birthday_at, '2019-%m-%d'));

/* Практическое задание по теме “Агрегация данных” №3
Описание задания: (по желанию) Подсчитайте произведение чисел в столбце таблицы
*/

-- создание таблиц
-- используется таблица из прошлого задания (storehouses_products)

-- наполнение нужными данными
-- таблица наполнена в прошлом задании

-- скрипт самого задания
select round(exp(sum(log(coalesce(value_for_multiplication, 1))))) as product from storehouses_products;